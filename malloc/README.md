memory
====

## program break
每个进程所分配的内存有很多部分组成，称为“段”（segment），表示对UNIX系统中进程虚拟内存的逻辑划分。

* 文本段（只读属性）。包含进程运行的程序机器语言指令。文本段只读属性，防止进程通过错误指针意味修改自身指令，又可以共享给同一程序的其他进程（映射到其他进程的虚拟地址空间）。
* 初始化数据段（用户初始化数据段， user-initialized data segment）。包含显示初始化的全局变量和静态变量（占用可执行文件的磁盘空间）。当程序加载到内存时，从可执行文件中读取这些变量的值。
* 未初始化数据段（零初始化数据段， zero-initialized data segment）。包含未初始化的全局变量和静态变量（不占用磁盘空间）。当加载程序时，分配这段内存，并初始化为0。
* 栈，动态增长和收缩的段，由栈帧（stack frames）组成。系统为每个当前调用的函数分配一个栈帧，存储函数的局部变量、实参、返回值。
* 堆，动态进行分配内存的段。

栈自高地址向低地址增长，堆则自低地址向高地址增长，两者之间为未分配的虚拟内存。栈与未分配内存的边界称为栈顶，堆与未分配内存的边界称为堆顶（program break）。

## 调整program break的大小

改变堆的大小（即分配或释放内存），就像内核改变进程的program break位置一样简单。在program break位置抬升以后，程序可以访问新分配的内存地址。
但此时物理内存页尚未分配，内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页实现映射。

program break 在为进程构造虚拟内存段时，初始位置在未初始化数据段（BSS段）之后（一般设置&bss_end）。之后根据进程的需求进行升高或降低。

brk, sbrk - change data segment size

    #include <unistd.h>

    int brk(void *addr);
                     Return 0 on success, or -1 on error.

    void *sbrk(intptr_t increment);
                     Return previous program break on success, or (void *)-1 on error.
系统调用`brk()`会将program break设置为参数`addr`所指定的位置。由于虚拟内存以页为单位进行分配，`addr`实际会四舍五入到下一个内存页的边界处。
当试图将program break设置为低于其初始值（即低于&bss_end）的位置时，有可能会导致无法预知的行为，导致段错误（segmentation fault）。

`sbrk()`将program break在原有地址上增加`increment`，`sbrk()`是在`brk()`基本上实现的库函数。若调用成功，则返回原来旧的program break的地址，换言之，若program break增加，
则返回值为新分配内存位置的指针。`sbrk(0)`返回当前program break的地址，不做改变。

## malloc & free

一般C语言使用`malloc()`和`free()`在堆上分配和释放内存，相比`brk()`和`sbrk()`：

*  属于C语言标准的一部分。
*  更易于在多线程中使用。
*  接口简单，允许分配小块内存。
*  允许随意释放内存块，它们被维护在一张空闲内存列表，在后续内存分配调用时循环使用。

.

    #include <stdlib.h>

    void *malloc(size_t size);
    void free(void *ptr);
    void *calloc(size_t nmemb, size_t size);
    void *realloc(void *ptr, size_t size);

一般，`free()`不会降低program break的位置，而是将这块内存加入到空闲内存列表中，供后续的`malloc()`函数循环使用。因为：

* 被释放的内存往往处于堆的中间，而非堆的顶部，因此降低program break是不可能的。
* 最大限度减少程序必须执行的`sbrk()`调用次数。（系统调用虽然小，却也颇为可观）
* 大多数情况下，降低program break的位置不会对分配大量内存的程序有多大帮助，因为它们通常倾向于反复分配或释放内存，而非释放所有内存再持续一段时间。

`free(NULL)`也是安全的。

**当进程终止时，其所占用的所有内存都将返回给操作系统，包括其中的堆内存。**基于内存的这一自动释放机制，对于那些分配了内存并在进程结束前持续使用的程序而言，通常会省略对free()的调用。
因为加入对`free()`的调用不仅会消耗大量CPU时间，还会使得代码趋于复杂。

但是最好能在程序中显式释放所有的已分配内存：

* 显式调用`free()`使得程序更具有可读性和可维护性；
* 使用malloc调试库查找程序的内存泄漏问题时，所有未显式释放的内存报告为内存泄漏，这使得发现真正的内存泄漏的工作复杂化。

## 内存泄漏

在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。（即程序不知道这段内存已经不会再使用，程序员需要显式free()才行）

内存泄漏通常情况下只能由获得程序源代码的程序员才能分析出來。然而，有不少人习惯于把任何不需要的内存使用的增加描述为内存泄漏，即使严格意义上来说这是不准确的。

在以下情況，内存泄漏导致较嚴重的后果：

* 程序运行后置之不理，并且随着时间的流失消耗越来越多的内存（比如服务器上的后台任务，尤其是嵌入式系统中的后台任务，这些任务可能被运行后很多年内都置之不理）；
* 新的内存被频繁地分配，比如当显示电脑游戏或动画视频画面时；
* 程序能够请求未被释放的内存（比如共享内存），甚至是在程序终止的时候；
* 泄漏在操作系统内部发生；
* 泄漏在系统关键驱动中发生；
* 内存非常有限，比如在嵌入式系统或便携设备中；
* 当运行于一个终止时内存并不自动释放的操作系统（比如AmigaOS）之上，而且一旦丢失只能通过重启来恢复。

**程序的内存泄漏，只有在程序终止时才会由操作系统回收，而操作系统也可以看作一个程序，操作系统内核的内存泄漏，只有重启才能解决。**

## malloc 实现

* 首先扫描空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存（具体实现的扫描策略有多种，如 first-fit / best-fito 等）。如果尺寸并非正好相等，则对其进行分割。
* 如果空闲内存列表中没有找到足够大的空闲内存块，则调用`sbrk()`分配更多的内存。为了减少调用`sbrk()`的次数，`malloc()`并非严格按照要求来分配内存，而是更大幅度来增加program break ，并将超出部分置于空闲内存列表；
* 为了保存内存块大小信息，`malloc()`分配内存块时，会额外分配几个字节用来存储这块内存大小的整数值，其值位于这块内存的起始处，而实际`malloc()`返回的内存地址是这一长度记录字节之后的地址；

分配好的内存块的格式：

* 长度记录块
* 调用者使用的内存块

## free 实现

当要释放一段内存块时，即将其置于空闲内存列表（双向链表）时，`free()`会使用这段内存块本身的空间来存放链表指针，将自身添加到列表中。

分配好的内存块的格式：

* 长度记录块
* 指向前一空闲内存块的指针
* 指向后一空闲内存块的指针
* 剩余的空闲内存
